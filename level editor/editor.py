#!/dev/python
# This script is shared as it is. May the force be with you.
# generates a json, a png and a h/c files from a simulated tile grid 
# each coordinate is a tile coordinate - but you can modify to be pixel refered
# if you modify NUM_ELEMENTS, ELEMENT_COLORS has to be also modified to have the
# the same amount of items. See the main loop to get the key shortcuts
# can open json files.
# the rest of the main parameters are selfexplained.
# the map can be scrolled with the arrow keys.

# the json structure:
# {
#        "type": "element1",
#        "tile_x": x,
#        "tile_y": y,
#        "properties": {
#            "property": N
#        }
#    },...

import pygame
import json
import os
from tkinter import filedialog, Tk, simpledialog
import re
# initial config 
SCREENW = 40
GRID_WIDTH =  512-SCREENW # the first 320 px are void
GRID_HEIGHT = 28
TILE_SIZE = 16
NUM_ELEMENTS = 20

WINDOW_WIDTH = 1024
WINDOW_HEIGHT = 720
SIDEBAR_WIDTH = 200

# scroll pasos
SCROLL_STEP_X = TILE_SIZE
SCROLL_STEP_FAST_X = TILE_SIZE * 8
SCROLL_STEP_Y = TILE_SIZE
SCROLL_STEP_FAST_Y = TILE_SIZE * 8

# TODO define better colors
ELEMENT_COLORS = [
    (255, 0, 0), (0, 255, 0), (0, 0, 255), (255, 255, 0),
    (255, 0, 255), (0, 255, 255), (128, 0, 0), (0, 128, 0),
    (0, 0, 128), (128, 128, 0), (128, 0, 128), (0, 128, 128),
    (64, 64, 64), (192, 192, 192), (255, 128, 0), (0, 255, 128),
    (128, 255, 0), (128, 0, 255), (0, 128, 255), (255, 0, 128)
]

SHORTCUT_KEYS = [
    pygame.K_1, pygame.K_2, pygame.K_3, pygame.K_4, pygame.K_5,
    pygame.K_6, pygame.K_7, pygame.K_8, pygame.K_9, pygame.K_0,
    pygame.K_v, pygame.K_h, pygame.K_d, pygame.K_r, pygame.K_g,
    pygame.K_a, pygame.K_m, pygame.K_i, pygame.K_b, pygame.K_j
]

ELEMENTS = [{"name": f"element{i+1}", "key": SHORTCUT_KEYS[i], "id": i } for i in range(NUM_ELEMENTS)]

grid = [[-1 for _ in range(GRID_WIDTH)] for _ in range(GRID_HEIGHT)]

def draw_grid(screen, offset_x, offset_y):
    for y in range(GRID_HEIGHT):
        for x in range(GRID_WIDTH):
            gx = x * TILE_SIZE - offset_x
            gy = y * TILE_SIZE - offset_y
            if gx + TILE_SIZE < 0 or gx > WINDOW_WIDTH - SIDEBAR_WIDTH:
                continue
            if gy + TILE_SIZE < 0 or gy > WINDOW_HEIGHT - 40:
                continue
            val = grid[y][x]
            rect = pygame.Rect(gx, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)
            pygame.draw.rect(screen, (30, 30, 30), rect, 1)
            if val != -1:
                pygame.draw.rect(screen, ELEMENT_COLORS[val], rect)

def draw_sidebar(screen, font, current_element):
    pygame.draw.rect(screen, (50, 50, 50), (WINDOW_WIDTH - SIDEBAR_WIDTH, 0, SIDEBAR_WIDTH, WINDOW_HEIGHT))
    for i, element in enumerate(ELEMENTS):
        y = 10 + i * 30
        color = ELEMENT_COLORS[i]
        pygame.draw.rect(screen, color, (WINDOW_WIDTH - SIDEBAR_WIDTH + 10, y, 20, 20))
        name = element["name"]
        label = font.render(f"{pygame.key.name(element['key'])}: {name}", True, (255, 255, 255))
        screen.blit(label, (WINDOW_WIDTH - SIDEBAR_WIDTH + 40, y))
    sel = font.render(f"Selecci√≥n: {ELEMENTS[current_element]['name']}", True, (255, 255, 0))
    screen.blit(sel, (WINDOW_WIDTH - SIDEBAR_WIDTH + 10, WINDOW_HEIGHT - 30))

def export_to_json(filename):
    out = []
    for y in range(GRID_HEIGHT):
        for x in range(GRID_WIDTH):
            v = grid[y][x]
            if v != -1:
                out.append({
                    "type": ELEMENTS[v]["name"],
                    "tile_x": x,
                    "tile_y": y,
                    "properties": {
                        "property": 0
                    }
                })
    with open(filename, "w") as f:
        json.dump(out, f, indent=4)

def import_from_json(filename):
    global grid
    with open(filename) as f:
        data = json.load(f)
    grid = [[-1 for _ in range(GRID_WIDTH)] for _ in range(GRID_HEIGHT)]
    for obj in data:
        x = obj["tile_x"]
        y = obj["tile_y"]
        try:
            idx = next(i for i, e in enumerate(ELEMENTS) if e["name"] == obj["type"])
        except StopIteration:
            idx = -1
        if 0 <= x < GRID_WIDTH and 0 <= y < GRID_HEIGHT and idx != -1:
            grid[y][x] = idx

def export_to_c(filename):
    used_elements = set()
    lines = []
    lines.append('// Script autogenerated code. Doublecheck it\n')

    lines.append('#include <genesis.h>\n')
    lines.append('#include "resources.h"\n')
    lines.append('#include "level_test.h"\n\n')
    ii=0
    for y in range(GRID_HEIGHT):
        for x in range(GRID_WIDTH):
            v = grid[y][x]
            if v != -1:
                ii=ii+1
  
    for y in range(GRID_HEIGHT):
        for x in range(GRID_WIDTH):
            v = grid[y][x]
            if v != -1:
                used_elements.add(v)


    lines.append('Image ')
    strlen = len(used_elements) 
     
    s = 0
    for i in sorted(used_elements):
        ename = ELEMENTS[i]["name"]
        m = re.search(r"\d+",ename)
        numero = 0
        
        if m:
            numero = int(m.group())
        if s < strlen-1:
            lines.append(f'* i{numero}, ')
        else: 
            lines.append(f'* i{numero};\n\n')
        s=s+1          
    



    for i in sorted(used_elements):
        lines.append(f'objproperties {ELEMENTS[i]["name"]}_props = {{ 0 }};\n')


     
    lines.append('\nSpawnEvent spawn_events[NUMSPR];\n\n')
    lines.append('void init_level_test(void)\n{\n')
    

    for i in sorted(used_elements):
        ename = ELEMENTS[i]["name"]
        m = re.search(r"\d+",ename)
        numero = 0
        if m:
            numero = int(m.group())
        lines.append(f'\ti{numero} = &ip{numero};\n')
    lines.append('\n')


    ii=0
    for y in range(GRID_HEIGHT):
        for x in range(GRID_WIDTH):
            v = grid[y][x]
            if v != -1:
                # eid = ELEMENTS[v]["id"]
                ename = ELEMENTS[v]["name"]
                m = re.search(r"\d+",ename)
                numero = 0
                if m:
                    numero = int(m.group())
                x = x+SCREENW
                
                lines.append(f'\tspawn_events[{ii}] = (SpawnEvent)') 
                lines.append('{')
                lines.append(f' {x}, {y}, {numero}, ')
                lines.append('&')
                lines.append(f'{ename}_props, FALSE, i{numero}, 0, i{numero}->tileset->numTile, {ii} ')
                lines.append('};\n')
                ii=ii+1
    lines.append('};\n')

    with open(filename, "w") as f:
        f.writelines(lines)

def export_to_h(filename):
    used_elements = set()
    lines = []
    lines.append('// Script autogenerated code. Doublecheck it\n')
    ii=0
    for y in range(GRID_HEIGHT):
        for x in range(GRID_WIDTH):
            v = grid[y][x]
            if v != -1:
                ii=ii+1
  
    for y in range(GRID_HEIGHT):
        for x in range(GRID_WIDTH):
            v = grid[y][x]
            if v != -1:
                used_elements.add(v)
    lines.append('#ifndef _H_LEVEL_TEST\n')
    lines.append('#define _H_LEVEL_TEST\n\n')                
    lines.append('#include <genesis.h>\n')
    lines.append('#include "resources.h"\n\n')
    lines.append(f'#define NUMSPR {ii}\n\n')
    lines.append('typedef struct {\n\tint property;\n} objproperties;\n\n')
    lines.append('typedef struct {\n\ts16 x;\n\ts16 y;\n\tu16 type;\n\tobjproperties * props;\n\tbool triggered;\n\tImage * img;\n\tint tile_index;\n\tint tilesize;\n\tint id;\n} SpawnEvent;\n\n')
    
  
   
    lines.append('extern Image ')
    strlen = len(used_elements) 
    s = 0
    for i in sorted(used_elements):
        ename = ELEMENTS[i]["name"]
        m = re.search(r"\d+",ename)
        numero = 0
        
        if m:
            numero = int(m.group())
        if s < strlen-1:
            lines.append(f'* i{numero}, ')
        else: 
            lines.append(f'* i{numero};\n\n')
        s=s+1


    for i in sorted(used_elements):
        lines.append(f'extern objproperties {ELEMENTS[i]["name"]}_props;\n')
    lines.append('\n')
     
    lines.append('extern SpawnEvent spawn_events[NUMSPR];\n\n')
    lines.append('void init_level_test(void);\n\n')
    
    lines.append('#endif')

    with open(filename, "w") as f:
        f.writelines(lines)

def export_to_png(filename):
    surf = pygame.Surface((GRID_WIDTH * TILE_SIZE, GRID_HEIGHT * TILE_SIZE))
    for y in range(GRID_HEIGHT):
        for x in range(GRID_WIDTH):
            val = grid[y][x]
            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)
            color = ELEMENT_COLORS[val] if val != -1 else (0, 0, 0)
            pygame.draw.rect(surf, color, rect)
    pygame.image.save(surf, filename)

def ask_filename(ext, save=True):
    Tk().withdraw()
    if save:
        return filedialog.asksaveasfilename(defaultextension=ext, filetypes=[(ext.upper(), f"*{ext}")])
    else:
        return filedialog.askopenfilename(filetypes=[(ext.upper(), f"*{ext}")])

def save_all_with_base(filename):
    base, _ = os.path.splitext(filename)
    export_to_json(base + ".json")
    export_to_h(base + ".h")
    export_to_c(base + ".c")
    export_to_png(base + ".png")
    print(f"Saved JSON, C y PNG as '{base}'")

def edit_element_names():
    root = Tk()
    root.withdraw()
    for i, elem in enumerate(ELEMENTS):
        new_name = simpledialog.askstring("Rename element", f"element {i+1} name:", initialvalue=elem["name"])
        if new_name:
            elem["name"] = new_name
    root.destroy()

def edit_single_element_name(current_element):
    root = Tk()
    root.withdraw()
    new_name = simpledialog.askstring("Editar nombre",
        f"Element name for {current_element+1} ({ELEMENTS[current_element]['name']}):",
        initialvalue=ELEMENTS[current_element]["name"])
    root.destroy()
    if new_name:
        ELEMENTS[current_element]["name"] = new_name

    return None
def draw_mouse_box(screen, font, offset_x, offset_y):
    mx, my = pygame.mouse.get_pos()
    if mx < WINDOW_WIDTH - SIDEBAR_WIDTH and my < WINDOW_HEIGHT - 20:
        gx = (mx + offset_x) // TILE_SIZE
        gy = (my + offset_y) // TILE_SIZE
        if 0 <= gx < GRID_WIDTH and 0 <= gy < GRID_HEIGHT:
            text = f"Tile X={gx}, Y={gy}"
            label = font.render(text, True, (255, 255, 255))
            box_w, box_h = label.get_size()
            box_rect = pygame.Rect(5, 5, box_w + 10, box_h + 6)
            pygame.draw.rect(screen, (0, 0, 0), box_rect)
            pygame.draw.rect(screen, (255, 255, 255), box_rect, 1)
            screen.blit(label, (10, 8))

def draw_slider_h(screen, offset_x):
    bar_y = WINDOW_HEIGHT - 20
    bar_rect = pygame.Rect(0, bar_y, WINDOW_WIDTH - SIDEBAR_WIDTH, 15)
    pygame.draw.rect(screen, (80, 80, 80), bar_rect)
    max_offset = (GRID_WIDTH * TILE_SIZE) - (WINDOW_WIDTH - SIDEBAR_WIDTH)
    if max_offset <= 0:
        return None
    thumb_w = max(50, (WINDOW_WIDTH - SIDEBAR_WIDTH) * (WINDOW_WIDTH - SIDEBAR_WIDTH) // (GRID_WIDTH * TILE_SIZE))
    thumb_x = int((offset_x / max_offset) * ((WINDOW_WIDTH - SIDEBAR_WIDTH) - thumb_w))
    thumb_rect = pygame.Rect(thumb_x, bar_y, thumb_w, 15)
    pygame.draw.rect(screen, (200, 200, 200), thumb_rect)
    pygame.draw.rect(screen, (255, 255, 255), thumb_rect, 2)
    return bar_rect, thumb_rect, max_offset

def draw_slider_v(screen, offset_y):
    bar_x = WINDOW_WIDTH - SIDEBAR_WIDTH - 20
    bar_rect = pygame.Rect(bar_x, 0, 15, WINDOW_HEIGHT - 20)
    pygame.draw.rect(screen, (80, 80, 80), bar_rect)
    max_offset = (GRID_HEIGHT * TILE_SIZE) - (WINDOW_HEIGHT - 20)
    if max_offset <= 0:
        return None
    thumb_h = max(50, (WINDOW_HEIGHT - 20) * (WINDOW_HEIGHT - 20) // (GRID_HEIGHT * TILE_SIZE))
    thumb_y = int((offset_y / max_offset) * ((WINDOW_HEIGHT - 20) - thumb_h))
    thumb_rect = pygame.Rect(bar_x, thumb_y, 15, thumb_h)
    pygame.draw.rect(screen, (200, 200, 200), thumb_rect)
    pygame.draw.rect(screen, (255, 255, 255), thumb_rect, 2)
    return bar_rect, thumb_rect, max_offset

def main():
    pygame.init()
    screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
    pygame.display.set_caption("Level editor for c")
    font = pygame.font.SysFont(None, 24)

    clock = pygame.time.Clock()

    running = True
    current_element = 0
    offset_x, offset_y = 0, 0

    dragging_h, dragging_v = False, False
    thumb_rect_h = bar_rect_h = None
    thumb_rect_v = bar_rect_v = None
    max_offset_h = max_offset_v = 0

    while running:
        screen.fill((0, 0, 0))
        draw_grid(screen, offset_x, offset_y)
        draw_sidebar(screen, font, current_element)
        draw_mouse_box(screen, font, offset_x, offset_y)

        slider_info_h = draw_slider_h(screen, offset_x)
        if slider_info_h:
            bar_rect_h, thumb_rect_h, max_offset_h = slider_info_h

        slider_info_v = draw_slider_v(screen, offset_y)
        if slider_info_v:
            bar_rect_v, thumb_rect_v, max_offset_v = slider_info_v

        pygame.display.flip()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            elif event.type == pygame.KEYDOWN:
                for i, element in enumerate(ELEMENTS):
                    if event.key == element["key"]:
                        current_element = i

                if event.key == pygame.K_RIGHT:
                    step = SCROLL_STEP_FAST_X if pygame.key.get_mods() & pygame.KMOD_SHIFT else SCROLL_STEP_X
                    offset_x = min(offset_x + step, (GRID_WIDTH * TILE_SIZE) - (WINDOW_WIDTH - SIDEBAR_WIDTH))
                elif event.key == pygame.K_LEFT:
                    step = SCROLL_STEP_FAST_X if pygame.key.get_mods() & pygame.KMOD_SHIFT else SCROLL_STEP_X
                    offset_x = max(offset_x - step, 0)
                elif event.key == pygame.K_DOWN:
                    step = SCROLL_STEP_FAST_Y if pygame.key.get_mods() & pygame.KMOD_SHIFT else SCROLL_STEP_Y
                    offset_y = min(offset_y + step, (GRID_HEIGHT * TILE_SIZE) - (WINDOW_HEIGHT - 20))
                elif event.key == pygame.K_UP:
                    step = SCROLL_STEP_FAST_Y if pygame.key.get_mods() & pygame.KMOD_SHIFT else SCROLL_STEP_Y
                    offset_y = max(offset_y - step, 0)
                elif event.key == pygame.K_s:
                    filename = ask_filename(".json")
                    if filename:
                        save_all_with_base(filename)
                elif event.key == pygame.K_o:
                    filename = ask_filename(".json", save=False)
                    if filename:
                        import_from_json(filename)
                elif event.key == pygame.K_p:
                    filename = ask_filename(".png")
                    if filename:
                        export_to_png(filename)
                elif event.key == pygame.K_e:
                    filename = ask_filename(".c")
                    if filename:
                        export_to_c(filename)
                elif event.key == pygame.K_n:
                    edit_element_names()
                elif event.key == pygame.K_w:
                    edit_single_element_name(current_element)
                    pass
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if thumb_rect_h and thumb_rect_h.collidepoint(event.pos):
                    dragging_h = True
                elif bar_rect_h and bar_rect_h.collidepoint(event.pos):
                    mx, my = event.pos
                    rel_x = max(0, min(mx, (WINDOW_WIDTH - SIDEBAR_WIDTH)))
                    thumb_w = thumb_rect_h.width
                    offset_x = int((rel_x / ((WINDOW_WIDTH - SIDEBAR_WIDTH) - thumb_w)) * max_offset_h)

                if thumb_rect_v and thumb_rect_v.collidepoint(event.pos):
                    dragging_v = True
                elif bar_rect_v and bar_rect_v.collidepoint(event.pos):
                    mx, my = event.pos
                    rel_y = max(0, min(my, (WINDOW_HEIGHT - 20)))
                    thumb_h = thumb_rect_v.height
                    offset_y = int((rel_y / ((WINDOW_HEIGHT - 20) - thumb_h)) * max_offset_v)

                else:
                    x, y = pygame.mouse.get_pos()
                    if x < WINDOW_WIDTH - SIDEBAR_WIDTH and y < WINDOW_HEIGHT - 20:
                        gx = (x + offset_x) // TILE_SIZE
                        gy = (y + offset_y) // TILE_SIZE
                        if gx < GRID_WIDTH and gy < GRID_HEIGHT:
                            grid[gy][gx] = current_element

            elif event.type == pygame.MOUSEBUTTONUP:
                dragging_h = False
                dragging_v = False

            elif event.type == pygame.MOUSEMOTION:
                if dragging_h:
                    mx, my = event.pos
                    rel_x = max(0, min(mx, (WINDOW_WIDTH - SIDEBAR_WIDTH)))
                    thumb_w = thumb_rect_h.width
                    offset_x = int((rel_x / ((WINDOW_WIDTH - SIDEBAR_WIDTH) - thumb_w)) * max_offset_h)
                if dragging_v:
                    mx, my = event.pos
                    rel_y = max(0, min(my, (WINDOW_HEIGHT - 20)))
                    thumb_h = thumb_rect_v.height
                    offset_y = int((rel_y / ((WINDOW_HEIGHT - 20) - thumb_h)) * max_offset_v)

        clock.tick(60)

    pygame.quit()

if __name__ == "__main__":
    main()

